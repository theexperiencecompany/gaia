from typing import Optional
from urllib.parse import quote

from app.api.v1.dependencies.oauth_dependencies import get_current_user
from app.config.settings import settings
from app.constants.cache import PLATFORM_LINK_TOKEN_PREFIX
from app.db.redis import redis_cache
from app.models.platform_models import (
    DisconnectPlatformResponse,
    GetPlatformLinksResponse,
    InitiatePlatformConnectResponse,
    LinkPlatformRequest,
    LinkPlatformResponse,
)
from app.services.oauth.oauth_state_service import create_oauth_state
from app.services.platform_link_service import Platform, PlatformLinkService
from fastapi import APIRouter, Depends, HTTPException

router = APIRouter()


@router.get("", response_model=GetPlatformLinksResponse)
async def get_platform_links(
    current_user: Optional[dict] = Depends(get_current_user),
) -> GetPlatformLinksResponse:
    """Get user's connected platform accounts."""
    if not current_user:
        raise HTTPException(status_code=401, detail="Not authenticated")

    user_id = current_user.get("user_id")
    if not isinstance(user_id, str):
        raise ValueError("user_id must be a string")
    platform_links = await PlatformLinkService.get_linked_platforms(user_id)

    return GetPlatformLinksResponse(platform_links=platform_links)


@router.post("/{platform}", response_model=LinkPlatformResponse)
async def link_platform(
    platform: str,
    body: LinkPlatformRequest,
    current_user: Optional[dict] = Depends(get_current_user),
) -> LinkPlatformResponse:
    """Link a platform account to the authenticated GAIA user.

    Requires a secure token generated by the bot via /api/v1/bot/create-link-token.
    The token is single-use and expires after 10 minutes.
    """
    if not current_user:
        raise HTTPException(status_code=401, detail="Not authenticated")

    if not Platform.is_valid(platform):
        raise HTTPException(status_code=400, detail="Invalid platform")

    # Look up and consume the token from Redis
    redis_client = redis_cache.client
    token_key = f"{PLATFORM_LINK_TOKEN_PREFIX}:{body.token}"

    token_data = await redis_client.hgetall(token_key)
    if not token_data:
        raise HTTPException(
            status_code=400,
            detail="Invalid or expired link token. Please request a new link from the bot.",
        )

    # Consume the token immediately to prevent replay attacks
    await redis_client.delete(token_key)

    token_platform = token_data.get("platform", "")
    platform_user_id = token_data.get("platform_user_id", "")

    if not platform_user_id:
        raise HTTPException(status_code=400, detail="Invalid token data")

    # Verify the platform in URL matches the platform in the token
    if token_platform != platform:
        raise HTTPException(
            status_code=400,
            detail="Platform mismatch. This token was not generated for this platform.",
        )

    user_id = current_user.get("user_id")
    if not isinstance(user_id, str):
        raise ValueError("user_id must be a string")

    profile: dict = {}
    if token_data.get("username"):
        profile["username"] = token_data["username"]
    if token_data.get("display_name"):
        profile["display_name"] = token_data["display_name"]

    try:
        result = await PlatformLinkService.link_account(
            user_id, platform, platform_user_id, profile=profile or None
        )
        return LinkPlatformResponse(**result)
    except ValueError as e:
        raise HTTPException(status_code=409, detail=str(e))


@router.delete("/{platform}", response_model=DisconnectPlatformResponse)
async def disconnect_platform(
    platform: str,
    current_user: Optional[dict] = Depends(get_current_user),
) -> DisconnectPlatformResponse:
    """Disconnect a platform from user account."""
    if not current_user:
        raise HTTPException(status_code=401, detail="Not authenticated")

    if not Platform.is_valid(platform):
        raise HTTPException(status_code=400, detail="Invalid platform")

    user_id = current_user.get("user_id")
    if not isinstance(user_id, str):
        raise ValueError("user_id must be a string")

    # Read platform_user_id before unlinking so we can clear the bot auth cache
    existing = await PlatformLinkService.get_linked_platforms(user_id)
    platform_entry = existing.get(platform)
    platform_user_id = platform_entry["platformUserId"] if platform_entry else None

    try:
        result = await PlatformLinkService.unlink_account(user_id, platform)
    except ValueError as e:
        raise HTTPException(status_code=404, detail=str(e))

    if platform_user_id:
        cache_key = f"bot_user:{platform}:{platform_user_id}"
        await redis_cache.client.delete(cache_key)

    return DisconnectPlatformResponse(**result)


@router.get("/{platform}/connect", response_model=InitiatePlatformConnectResponse)
async def initiate_platform_connect(
    platform: str,
    current_user: Optional[dict] = Depends(get_current_user),
) -> InitiatePlatformConnectResponse:
    """Initiate platform connection via OAuth or manual instructions.

    Returns:
        - OAuth URL if credentials configured
        - Manual instructions if OAuth not configured
    """
    if not current_user:
        raise HTTPException(status_code=401, detail="Not authenticated")

    if not Platform.is_valid(platform):
        raise HTTPException(status_code=400, detail="Invalid platform")

    user_id = current_user.get("user_id")
    if not isinstance(user_id, str):
        raise ValueError("user_id must be a string")

    # Discord OAuth flow
    if platform == "discord" and settings.DISCORD_OAUTH_CLIENT_ID:
        state = await create_oauth_state(
            user_id=user_id,
            redirect_path="/settings?section=linked-accounts",
            integration_id="discord",
        )

        auth_url = (
            f"https://discord.com/api/oauth2/authorize"
            f"?client_id={settings.DISCORD_OAUTH_CLIENT_ID}"
            f"&redirect_uri={quote(settings.DISCORD_OAUTH_REDIRECT_URI)}"
            f"&response_type=code"
            f"&scope=identify"
            f"&state={state}"
        )
        return InitiatePlatformConnectResponse(
            auth_url=auth_url, auth_type="oauth", instructions=None
        )

    # Slack OAuth flow
    if platform == "slack" and settings.SLACK_OAUTH_CLIENT_ID:
        state = await create_oauth_state(
            user_id=user_id,
            redirect_path="/settings?section=linked-accounts",
            integration_id="slack",
        )

        auth_url = (
            f"https://slack.com/oauth/v2/authorize"
            f"?client_id={settings.SLACK_OAUTH_CLIENT_ID}"
            f"&redirect_uri={quote(settings.SLACK_OAUTH_REDIRECT_URI)}"
            f"&user_scope=identity.basic"
            f"&state={state}"
        )
        return InitiatePlatformConnectResponse(
            auth_url=auth_url, auth_type="oauth", instructions=None
        )

    # Telegram manual flow (no OAuth)
    if platform == "telegram":
        bot_username = settings.TELEGRAM_BOT_USERNAME or "gaia_bot"
        return InitiatePlatformConnectResponse(
            auth_url=None,
            auth_type="manual",
            instructions=f"Open Telegram and message @{bot_username} with /auth to link your account.",
            action_link=f"https://t.me/{bot_username}",
        )

    raise HTTPException(status_code=501, detail=f"{platform} OAuth not configured")
